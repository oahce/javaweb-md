

# 常量的概念
> 常量可以分为两种：字面常量和字符常量

## 字面常量和字符常量

字面常量：1、2、3、1.2、'a'、'b'、'c'、"Hello"、true、false等都是字面常量
字符常量：final修饰的变量(后续详细说明)

---

# 变量的概念
> 变量本质是“可操作的一段存储空间”，空间大小确定但是放什么值不确定，因为java是强类型的，所以定义变量之前必须定义这个变量的类型，比如：int a。a是变量名，通过它来找到这段空间，int则是定义这个空间的大小。

## 1) 变量的定义

定义变量a，此处a是局部变量(在方法内)：
```java
public class App {  
    public static void main( String[] args ) {  
        int a;
	}  
}
```
上面代码反编译后的样子是：
```java
public class App {  
    public App() {  
    }  
  
    public static void main(String[] args) {  
    }  
}
```
这也是为什么有“使用局部变量时必须初始化变量“规定的原因。

如果将a定义为 成员变量(类变量，不在方法内)：
```java
public class App {  
    int a;  
	public static void main( String[] args ) {  
		int a;  
	}  
}
```
上面的代码编译后的样子是：
```java
public class App {  
    int a;  
  
	public App() {  
	}  
	
	public static void main(String[] args) {  
	}  
}
```

## 2) 变量的赋值

为变量赋值的方式是(此处是局部变量)：
```java
public class App {  
    public static void main( String[] args ) {  
        int a;  
		a = 10; //或者int a = 10; 
	}  
}
```
上面是把10这个值赋值给int类型的变量a，编译后的样子是：
```java
public class App {  
    public App() {  
    }  
  
    public static void main(String[] args) {  
        int a = 10;  
	}  
}
```
就算你多写成两行，编译器会帮你写成一行。

如果“成员变量”不赋值：
```java
public class App {  
    int a;  
	public static void main(String[] args) {  
	}  
}
```
反编译后：
```java
public class App {  
    int a;  
  
	public App() {  
	}  
	
	public static void main(String[] args) {  
	}  
}
```
相比局部变量，成员变量不会“消失”(事实上成员变量都各自存在自己的默认值，int类型成员变量默认值是0)。

多次赋值时编译器不会帮你检测是否被使用，从而只保留最后一个：
```java
public static void main( String[] args ) {  
    int a;  
	a = 10;  
	a = 20;  
	a = 30;  
	a = a + 1;  
	a = 9;  //反编译不只是保留这一行，其他赋值操作也会被保留
	System.out.println(a);  
}
```

对下面的代码进行编译得到App.class
```java
public class App {  
    public static void main( String[] args ) {  
        int a = 10;  
		int b = 20;  
		int c = a + b;    
	 }  
}
```
对字节码文件进行反汇编操作，命令： javap -v App.class > App.txt  
```java
Classfile /C:/Users/Administrator/IdeaProjects/demo/target/classes/com/infchd/App.class  
  Last modified 2022-3-4; size 442 bytes  
  MD5 checksum c66c8af336337cef28f720f9826f6a3d  
  Compiled from "App.java"  
public class com.infchd.App  
  minor version: 0  
  major version: 52  
  flags: ACC_PUBLIC, ACC_SUPER  
Constant pool:  
   #1 = Methodref          #3.#21         // java/lang/Object."<init>":()V  
   #2 = Class              #22            // com/infchd/App  
   #3 = Class              #23            // java/lang/Object  
   #4 = Utf8               <init>  
   #5 = Utf8               ()V  
   #6 = Utf8               Code  
   #7 = Utf8               LineNumberTable  
   #8 = Utf8               LocalVariableTable  
   #9 = Utf8               this  
  #10 = Utf8               Lcom/infchd/App;  
  #11 = Utf8               main  
  #12 = Utf8               ([Ljava/lang/String;)V  
  #13 = Utf8               args  
  #14 = Utf8               [Ljava/lang/String;  
  #15 = Utf8               a  
  #16 = Utf8               I  
  #17 = Utf8               b  
  #18 = Utf8               c  
  #19 = Utf8               SourceFile  
  #20 = Utf8               App.java  
  #21 = NameAndType        #4:#5          // "<init>":()V  
  #22 = Utf8               com/infchd/App  
  #23 = Utf8               java/lang/Object  
{  
  public com.infchd.App();  -->构造方法
    descriptor: ()V  
    flags: ACC_PUBLIC  
    Code:  --> 代码开始
      stack=1, locals=1, args_size=1  
         0: aload_0  
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V  
         4: return  
      LineNumberTable:  
        line 3: 0  
      LocalVariableTable:  
        Start  Length  Slot  Name   Signature  
            0       5     0  this   Lcom/infchd/App;  
  
  public static void main(java.lang.String[]);   -->main方法
    descriptor: ([Ljava/lang/String;)V  
    flags: ACC_PUBLIC, ACC_STATIC  
    Code:   --> 代码开始
      stack=2, locals=4, args_size=1  
         0: bipush        10   --> 10
         2: istore_1  
         3: bipush        20   --> 20
         5: istore_2  
         6: iload_1  
         7: iload_2  
         8: iadd   --> 加操作
         9: istore_3   --> 存操作
        10: return  
      LineNumberTable:  
        line 5: 0  
        line 6: 3  
        line 7: 6  
        line 9: 10  
      LocalVariableTable:  
        Start  Length  Slot  Name   Signature  
            0      11     0  args   [Ljava/lang/String;  
            3       8     1     a   I  
            6       5     2     b   I  
           10       1     3     c   I  
}
```
更详细的说明在后续认识jvm部分中进行，你会认识到赋值等各个操作更深层的原理。

## 3) 变量的内存

- 数据类型决定了在内存中开辟的空间大小

练习：
```java
public static void main(String[] args) {  
    int num1 = 10;  
	int num2 = 20;  
	num1 = num2;  
	num2 = num2 + 10;  
	num1 = num2 - 10;  
	num2 = num1;  
	System.out.println(num1);  
	System.out.println(num2);  
  
}
```
结果：20，20

## 4) 变量的作用域

- 成员变量的作用域是类中，类中的任何方法都能访问到(注意静态规则)
- 局部变量的作用域是它所在的方法内

```java
public class App {  
    int c = 20;  
	public void fun1(){  
		System.out.println(c); //YES  
		
		System.out.println(a); //NO  报错
		int a = 10;  
		System.out.println(a); //YES  
	}  
	
	public void fun2(){  
		System.out.println(c); //YES  
	
		int a = 30;//它是对a重新定义，和fun1中的局部变量a没有任何关系  
		System.out.println(a); //YES  
	}  

	public void fun3(){  
		int a = 10;  
		{  
			System.out.println(a); //YES  
			--> int a = 20; // NO 此处就是对变量重复定义了 报错
			int b = 20;  
		}  
		System.out.println(b); //NO 无法访问局部变量b  报错
	}
  
}
```