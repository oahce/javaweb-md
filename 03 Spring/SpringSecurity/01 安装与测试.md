### 依赖导入
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

### 测试
```java
@SpringBootTest
class WeblogApplicationTests {

    @Test
    void contextLoads() {
        PasswordEncoder pe = new BCryptPasswordEncoder();
        String encodes = pe.encode("password");
        System.out.println(encodes);
        boolean b = pe.matches("password",encodes);
        System.out.println(b);
    }
}
```

### config(注入)
```java

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig {

    @Bean
    public PasswordEncoder getPassWord(){
        return new BCryptPasswordEncoder();
    }
}
```

### service
```java
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private PasswordEncoder pw;

    @Override
    public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {
        if(!"admin".equals(userName)){
            throw new UsernameNotFoundException("用户名不存在");
        }
        String password = pw.encode("123456");
        return new User(userName,password, AuthorityUtils.commaSeparatedStringToAuthorityList("admin,guest"));
    }
}
```

### 自定义登陆过程

1. SecurityConfig.java
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //表单登陆
                .loginProcessingUrl("/authentication/form") //登陆表单提交的地址
                .loginPage("/login") //自定义登陆页面
                .successForwardUrl("/index"); //默认就是/，注意必须是post请求
        http.authorizeRequests()
                .antMatchers("/login").permitAll() //解决重定向次数过多 对特定请求放行
                .anyRequest().authenticated(); //拦截所有请求
        http.csrf().disable(); //暂时关闭csrf
    }

    @Bean
    public PasswordEncoder getPassWord(){
        return new BCryptPasswordEncoder();
    }
}
```
2. UserController
```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
@Controller
public class UserController {

    @PostMapping("/index")
    public String index(){
        return "index";
    }

    @GetMapping("/login")
    public String login(){
        return "login";
    }
    @GetMapping("/more")
    public String more(){
        return "more";
    }

}
```
3. UserDetailsServiceImpl
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private PasswordEncoder pw;

    @Override
    public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {
        if(!"admin".equals(userName)){
            throw new UsernameNotFoundException("用户名不存在");
        }
        String password = pw.encode("123456");
        System.out.println("加密密码是："+password);
        return new User(userName,password, AuthorityUtils.commaSeparatedStringToAuthorityList("admin,guest"));
    }
}
```
4. login.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    hello!
    <h3>login</h3>
    <form action="/authentication/form" method="post">
        <table>
            <tr>
                <td>username</td>
                <td><input type="text" name="username"></td>
            </tr>
            <tr>
                <td>username</td>
                <td><input type="password" name="password"></td>
            </tr>
            <tr>
                <td colspan="2"><button type="submit">submit</button> </td>
            </tr>
        </table>
    </form>
</body>
</html>
```

5. error处理
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //表单登陆
                .loginProcessingUrl("/authentication/form") //登陆表单提交的地址
                .loginPage("/login") //自定义登陆页面
                .successForwardUrl("/index") //默认就是/，注意必须是post请求
                .failureForwardUrl("/error"); //自定义失败路径
        http.authorizeRequests()
                .antMatchers("/error").permitAll() //
                .antMatchers("/login").permitAll() //解决重定向次数过多 对特定请求放行
                .anyRequest().authenticated(); //拦截所有请求
        http.csrf().disable(); //暂时关闭csrf
    }

    @Bean
    public PasswordEncoder getPassWord(){
        return new BCryptPasswordEncoder();
    }
}
```

6. 为什么login页面的参数必须是username和password，请求必须是post
```java
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.lang.Nullable;
import org.springframework.security.authentication.AuthenticationServiceException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.util.Assert;

public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {
    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = "username";
    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = "password";
    private String usernameParameter = "username";
    private String passwordParameter = "password";
    private boolean postOnly = true;

    public UsernamePasswordAuthenticationFilter() {
        super(new AntPathRequestMatcher("/login", "POST"));
    }

    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        if (this.postOnly && !request.getMethod().equals("POST")) {
            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());
        } else {
            String username = this.obtainUsername(request);
            String password = this.obtainPassword(request);
            if (username == null) {
                username = "";
            }

            if (password == null) {
                password = "";
            }

            username = username.trim();
            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
            this.setDetails(request, authRequest);
            return this.getAuthenticationManager().authenticate(authRequest);
        }
    }

    @Nullable
    protected String obtainPassword(HttpServletRequest request) {
        return request.getParameter(this.passwordParameter);
    }

    @Nullable
    protected String obtainUsername(HttpServletRequest request) {
        return request.getParameter(this.usernameParameter);
    }

    protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) {
        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));
    }

    public void setUsernameParameter(String usernameParameter) {
        Assert.hasText(usernameParameter, "Username parameter must not be empty or null");
        this.usernameParameter = usernameParameter;
    }

    public void setPasswordParameter(String passwordParameter) {
        Assert.hasText(passwordParameter, "Password parameter must not be empty or null");
        this.passwordParameter = passwordParameter;
    }

    public void setPostOnly(boolean postOnly) {
        this.postOnly = postOnly;
    }

    public final String getUsernameParameter() {
        return this.usernameParameter;
    }

    public final String getPasswordParameter() {
        return this.passwordParameter;
    }
}
```
我们可以自定义修改参数名
```java
@Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //表单登陆
                .usernameParameter("username123")
                .passwordParameter("password123")
        ...
    }
```

### 自定义登陆成功处理器
.successForwardUrl("/index") 本质是请求转发：forward(request, response); 所以无法跳转前后端分离的页面。
我们可以重新一个处理器进行指定：
```java
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class WeblogAuthenticationSuccessHandle implements AuthenticationSuccessHandler {
    private String url;
    public WeblogAuthenticationSuccessHandle(String url) {
        this.url = url;
    }

    @Override
    public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {
        httpServletResponse.sendRedirect(url);
    }
}
```
配置类修改：
```java
@Override
    protected void configure(HttpSecurity http) throws Exception {
        http.formLogin() //表单登陆
                .loginProcessingUrl("/authentication/form") //登陆表单提交的地址
                .loginPage("/login") //自定义登陆页面
                //.successForwardUrl("/index") //默认就是/，注意必须是post请求
                .successHandler(new WeblogAuthenticationSuccessHandle("https://www.baidu.com"))
        ...
    }
```


